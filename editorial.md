# 진짜 최종 구데기컵 2 2 에디토리얼

(하고 싶은 말)

## 들어가기 전에

올해 구데기컵을 부활시키기 위해 제2회 진짜 최종 구데기컵 2를 열었습니다. 대회 이름에 2가 두 개고 마침 2022년이라서 시작 시각도 22:22:22고 만점도 222,222점입니다.

* "셀 수 없는 문제를 해결하신 모든 분들께 solved.ac 배경과 뱃지를 드립니다": 문제 번호가 자연수가 아니라서 셀 수 없습니다. 아무 문제나 하나 풀면 드립니다.
* "⅔ 이하의 인터랙티브 문제가 출제될 예정입니다": 원래는 문제 번호가 ⅔번 이하인 인터랙티브 문제를 출제하려고 했는데, 수식에 이모지를 섞어넣을 수 있다는 사실을 알아버렸습니다. 이제부터 📏 < 0입니다.

## ![1](https://user-images.githubusercontent.com/4417431/159480297-0b813cb4-d176-47c8-aa5d-50ba1b943c48.png)번. 한별 찍기
_출제자: shiftpsh,_
_최고 득점자: shiftpsh (0분, 0점)_

예제에 주어진 한별이를 그대로 출력하면 됩니다. 노 솔브 방지용 문제입니다.

## ![2](https://user-images.githubusercontent.com/4417431/159480764-988028d3-5238-42f2-981f-8e25d6a47aa8.png)번. Binary Game 2

## ![3](https://user-images.githubusercontent.com/4417431/159481765-13b348f4-29cb-45fb-81b3-0dec2141c30f.png)번. Fewest Moves Challenge

_출제자: kipa00,_
_최고 득점자: kipa00 (0분, 0점)_

Fewest Moves Challenge를 알아야 할 것처럼 방대한 분량으로 잔뜩 설명되어 있는데, **다 필요없고** [Thistlethwaite's 4-phase Algorithm](https://www.jaapsch.net/puzzles/thistle.htm)이 평균 31 회전 정도에 큐브를 맞추므로 이 알고리즘을 구현하면 됩니다. 신의 수를 구하는 데 사용되어 익히 알려진 [Kociemba's 2-phase Algorithm](http://kociemba.org/twophase.htm)은 모든 큐브를 30 회전 안에 맞출 수 있으나, 전처리 과정이 너무 길고 `constexpr` 등을 사용할 경우 파일의 크기가 너무 커져서 이 문제에서는 사용이 거의 불가능합니다.

굳이 WCA 규칙을 적어놓은 이유는, WCA 권고사항에 따라 **불필요한 이동이 없는 25 회전 스크램블**만을 입력으로 사용했기 때문입니다. 따라서 superflip 등 다루기 복잡한 상태만 입력으로 들어오는 것은 생각하지 않으셔도 됩니다.

정해 풀이와 상관없이 FMC는 재밌으니 문제에서 부분 점수를 받으신 분은 저와 함께 FMC를 해 주실 거라 믿습니다.

아래는 4-phase algorithm을 구현할 때 신경써야 할 부분입니다. 1981년 원본 논문에서는 대칭이동 등을 고려해서 테이블의 크기를 줄이는 경우 몇 시간 정도가 소요된다고 적혀 있지만, *40년 동안 컴퓨터가 엄청나게 빨라지기도 했고* 아래 적힌 알고리즘 최적화를 모두 시행하면 전처리에 고작 **200ms**도 걸리지 않습니다.

### Phase 1

2 048개의 경우밖에 안 되지만, 그냥 BFS 전처리를 해 두는 것이 정신 건강에 좋습니다.

### Phase 2

경우의 수는 1 082 565가지이며 큐브의 스티커는 총 54개이므로 전처리에 상당한 시간이 소요됩니다. 이 시간을 줄이기 위해, 코너와 엣지는 항상 서로 다른 위치에 있다는 사실을 이용합시다.

- 코너는 총 3<sup>7</sup> = 2 187가지이고 가능한 모든 14가지의 연산에 대해 미리 어떤 상태로 가는지 전처리를 해 둡시다. 스티커는 코너의 24개만 보면 됩니다. 
- 마찬가지로 엣지는 총 <sub>12</sub>C<sub>4</sub> = 495가지이고 가능한 모든 14가지의 연산에 대해 어떤 상태로 가는지 전처리합니다. 스티커는, 1단계에서 이미 엣지 오리엔테이션을 정렬했으므로 올바른 엣지 스티커 12개만 보면 됩니다.

이 연산 정보를 사용하여 1 082 565개의 상태를 BFS로 전부 탐색하면, 연산하는 데 큐브를 직접 돌려볼 필요가 없으므로 전처리 속도가 대단히 빨라집니다.

### Phase 3

연산이 가장 힘든 부분입니다. 역시 코너와 엣지로 쪼개되, 다른 phase와 달리 코너의 경우 G<sub>2</sub>/G<sub>3</sub>가 group이 **되지 않는다**는 사실에 주의해야 합니다.

- 따라서 coset의 코너의 factor가 420임에도 불구하고 코너의 경우는 어쩔 수 없이 8! = 40 320가지의 경우를 다 봐 줘야 합니다. 가능한 연산 개수는 10가지이고, 스티커는 2단계에서 코너 오리엔테이션을 정렬했으므로 8개만 보면 됩니다.
- 엣지의 경우에는 subgroup이 되므로 각각의 위치에 넣어주기만 하면 되며, 70가지를 봐 주면 됩니다. 마찬가지로 가능한 연산 개수는 10가지이고, 스티커는 12개만 보면 됩니다.

이제, 이 연산 정보를 합쳐서 2 822 400개의 상태에 대해 96개의 초기 상태에서 multi-source BFS를 시행합니다.

### Phase 4

Phase 2와 마찬가지로, 코너와 엣지를 쪼개어 계산하면 됩니다. 여기까지 되었다면, 실제로 남은 상태의 개수가 663 552개이므로 특별히 더 어려운 부분은 없습니다.

### 부분 점수에 대해

- 초보자용 해법은 평균 110-120 회전이 소모되므로 점수를 받을 수 없습니다.
- CFOP 해법은 최적화하지 않으면 평균 60-65 회전 정도가 소모되고, 최적화하면 평균 55-60 회전 정도가 소모됩니다. 65 회전의 경우 3 472.22점, 55 회전의 경우 13 888.88점 정도를 얻을 수 있습니다.
- Roux 해법은 평균 48 회전 정도가 소모됩니다. 평균 48 회전의 경우 받을 수 있는 점수는 36 652.96점입니다.
- Petrus 해법에 ZBLL을 섞으면 평균 40-45 회전 정도가 소모됩니다. 평균 40 회전의 경우 받을 수 있는 점수는 111 111점입니다. 여기에 ZBLL 대신 본문에 소개된 AB5C + Insertion을 사용하면 점수를 조금 더 받을 수 있을지도 모릅니다.
- 평균 40 회전부터는 1 회전을 줄이는 것이 최소 16 000점에서 최대 29 000점까지 차이가 나므로, 생각보다 점수를 못 받고 있다면 혹시 한 번에 할 수 있는 이동을 두 번으로 나누어 출력했거나(R R2는 R'으로 출력할 수 있습니다) 불필요한 U 면 회전이 없는지 확인합시다.

35 회전에 가까워질수록 비슷한 회전수에 대해서 점수 간격을 오히려 넓힌 이유는, 회전 수가 줄어들수록 회전 수를 더 줄이기 힘들기 때문이기도 하고, 계획한 알고리즘을 정확히 사용하지 않는 경우 점수 차이를 크게 주기 위해서이기도 합니다.

## ![4](https://user-images.githubusercontent.com/4417431/159481027-fedee281-4f4a-4d7f-8b8e-427eefebd0a9.png)번. _multiple_ edges

## ![5](https://user-images.githubusercontent.com/4417431/159481133-ea41767d-f5be-49a3-ad41-b51112e6c92b.png)번. Baekjoon Wordline Judge

## ![6](https://user-images.githubusercontent.com/4417431/159481232-3aa3fdf6-af20-47e2-8a8f-6f316b091f06.png)번.  (=BOJ 문제 번호)
_출제자: shiftpsh,_
_최고 득점자: shiftpsh (0분, 0점)_

제출 번호가 몇 번이 부여될지 예상하고 잘 제출해야 합니다. 제출이 몰리지 않는 시간대에 시도한다면 맞을 가능성이 더 높아질 수 있습니다.

## ![7](https://user-images.githubusercontent.com/4417431/159481340-8269345b-2208-4ab4-9291-8be95fcb5e09.png)번. 문제 이름

## ![8](https://user-images.githubusercontent.com/4417431/159481340-8269345b-2208-4ab4-9291-8be95fcb5e09.png)번. 문제 이름
_출제자: shiftpsh,_
_최고 득점자: shiftpsh (0분, 0점)_

같은 번호, 같은 이름과 같은 지문의 문제 중 더 아래에 있는 문제였습니다. 출제자가 다른데, 위에 있는 문제는 실제로 출제자가 현재 훈련소에서 훈련을 받고 있고, 아래에 있는 문제는 출제자가 최근에 훈련소에서 수료했습니다.

solved.ac 슬랙/디스코드에 훈련소 편지 작성 링크를 미리 공지했던 만큼 편지를 6장만 썼어도 **쉽게 맞힐 수 있는** **노솔브 방지 문제**였습니다. 출제자가 훈련소에서 받은 편지는 106장이며 정답이 될 수 있는 단어는 총 92개입니다. 이 중 유추할 수 있을 법한 단어들을 소개합니다.

* `잘` ('`잘` 지내고 있나요?' 같은)
* `하이`
* `훈련소`
* `편지`
* `제목` (내용이 `제목`으로 시작하는 편지가 있어서 얻어걸릴 수 있었겠습니다)

아래 단어들은 안타깝게도 정답이 아닙니다.

* `안녕하세요` (`안녕하세요.`와 `안녕하세요,`는 있었습니다)
* `시프트`, `시프트님` 등

마지막으로 정말 유추하기 힘들었을 듯한 단어들을 몇 개만 소개합니다.

* `블라디미르`
* `次元の民`
* `https://youtu.be/JwqagN3t16A`
* `꽶윋뾆휊깶!`
* `##시간제한`

안타깝게도 코로나 확진으로 격리된 3월 5일 이후의 편지는 수령하지 못해서 정답에 없습니다.

## ![9](https://user-images.githubusercontent.com/4417431/159481562-1cf2838c-8b4e-42b1-b87f-bfbc2743f59f.png)번. 제1회 구데기그릇 (홀수형)

## ![10](https://user-images.githubusercontent.com/4417431/159481986-271660e3-5667-4f1a-b417-a6a84718f2db.png)번. 제1회 구데기그릇 (짝수형)

## ![11](https://user-images.githubusercontent.com/4417431/159481708-96effd29-70d8-4964-b218-5ab76438a444.png)번. 하이퍼하게 누울 하이퍼 자리를 찾아라
_출제자: shiftpsh,_
_최고 득점자: shiftpsh (0분, 0점)_

[누울 자리를 찾아라](https://www.acmicpc.net/problem/1652)의 11차원 버전입니다. 입력이 sparse하게 들어온다는 차이점이 있습니다. 이를 잘 이용해 봅시다.

### 서브태스크 1 (11,111점)
[누울 자리를 찾아라](https://www.acmicpc.net/problem/1652)를 풀듯이 풀면 됩니다. 복잡도 O(_N_<sup>11</sup>)에 해결할 수 있습니다.

### 서브태스크 2 (100,000점)
위와 같은 방법으로 풀면 시간과 공간이 부족합니다(50<sup>11</sup> ~= 4 &times; 10<sup>18</sup>).

우선 1차원에서부터 차근차근 생각해 봅시다. 예를 들어, _N_ = 10이고, 2, 6 위치에 짐이 놓여 있다면 

<p align="center">
🔲⬛🔲🔲🔲⬛🔲🔲🔲🔲
</p>

와 같은 상태가 되고, 잠을 잘 수 있는 공간은 가운데 세 칸과 맨 오른쪽 네 칸으로 2곳입니다.

생각하기 쉽게 0, <em>N</em> + 1 (=11) 위치에 추가로 짐을 놓는다고 가정하고, 이를 배열 [0, 2, 6, 11]로 나타냅시다. 잠을 잘 수 있는 공간은 이 배열에서 인접한 값이 3 이상 차이나는 경우의 수라는 것을 알 수 있습니다. 따라서 1차원의 경우에는 배열을 정렬한 후 이런 경우의 수를 세 주면 되며, 이는 <em>N</em>과 상관없는 O(<em>K</em> log <em>K</em>) 알고리즘입니다.

다시 11차원으로 돌아오면, 이런 1차원 공간이 축마다 <em>N</em><sup>10</sup>개로 총 11<em>N</em><sup>10</sup>개가 존재함을 알 수 있습니다. 여전히 꽤 큰 수입니다.

하지만 짐이 <em>K</em>개밖에 없으므로, 짐이 존재하는 1차원 공간도 11<em>K</em> 개까지밖에 존재할 수 없습니다. 짐이 존재하는 1차원 공간만 고려해 준다면 O(<em>K</em> log <em>K</em>)만에 문제를 해결할 수 있습니다.

### 서브태스크 3 (111,111점)
이 문제의 출력이 될 수 있는 수는 <em>N</em><sup>10</sup> + O(<em>K</em>)입니다. 5,000<sup>10</sup>은 64비트 정수 범위에 들어오지 않으므로 조금 더 큰 자료형을 사용해 해결해야 합니다.

500,000<sup>10</sup> &lt; 10<sup>37</sup>이므로 GNU C++에서는 `__int128`로 해결할 수 있습니다.

## ![12](https://user-images.githubusercontent.com/4417431/159480900-7a162c89-02fd-4ff0-aff9-88145c359537.png)번. 🅰➕🅱
